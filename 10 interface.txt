доступ interface Имя { //имя с большой буквы
возвращаемый-тип имя-метода1 { список-параметров);
возвращаемый-тип имя-метода2{ список-параметров);
тип финальное-имя-переменной1 = значение;
тип финальное-имя-переменной2 = значение;
...

public interface Series { //public // должен находиться в файле с таким же именем
int getNext(); // возврат следующего числа в последовательности
void reset(); // сброс
void setStart(int x); // установка начального значения
}

class имя-класса extends суперкласс implements интерфейс1, интерфейс2 {
// тело класса
}
Метод, определенный интерфейсом, должен быть реализован как public,
потому что все члены интерфейса неявно являются открытыми.

если класс включает интерфейс, но не полностью реализует методы, определенные в этом интерфейсе,
тогда класс должен быть объявлен абстрактным. Создать объекты такого класса не удастся, но его можно
применять в качестве абстрактного суперкласса, позволяя подклассам обеспечивать полную реализацию.

можно объявить ссылучную переменную интерфейсного типа, такая переменная может ссылаться на любой объект,
реализующий её интерфейс, также как ссылка на суперкласс для подкласса:
interface intfc{...}
class test{...}
test obj = new test();
intrfc smth;
smth = obj;
Переменной ссылки на интерфейс известны только методы, объявленные в ее
интерфейсном типе. Таким образом, smth нельзя применять для доступа к каким-то
другим переменным или методам, которые могли бы поддерживаться объектом.

переменные, в интерфейсах неявно являются public, static и final.

Один интерфейс может быть унаследован при помощи extends. Когда класс реализует интерфейс, унаследованный от
другого интерфейса, он должен предоставить реализации всех методов, требуемых цепочкой наследования интерфейса.

Стандартный метод интерфейса не требует реализации в классе и имеет тело, при объявлении нужно написать default

С применением формы super в унаследованном интерфейсе можно явно ссылаться на стандартную реализацию:
ИмяИнтерфейса.super.имяМетода()
Например, если в Beta нужно сослаться на стандартный метод reset ( ) из
Alpha, то вот какой оператор можно использовать:
Alpha.super.reset();

статический метод, определенный в интерфейсе, может вызываться независимо от любого объекта.
ИмяИнтерфейса.имяСтатическогоМетода()

закрытый метод, может вызываться только стандартным или закрытым методом, определенным в том же интерфейсе.
Он указан как private, его нельзя использовать в коде вне интерфейса, в котором он определен. Также и с
производными интерфейсами, тк закрытый метод интерфейса не наследуется. Он позволяет стандартным
методам использовать общий фрагмент кода, избегая дублирования кода.


                             Запечатанные интерфейсы:
    Запечатанный интерфейс объявляется аналогично запечатанному классу с применением ключевого слова sealed. Запечатанный
интерфейс использует свою конструкцию permits для указания классов, которым разрешено его реализовывать, и/или
интерфейсов, которым позволяется его расширять. Разрешенный интерфейс должен быть объявлен либо как non-sealed, либо
как sealed.
